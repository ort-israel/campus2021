{"version":3,"sources":["../src/msr_plain.js"],"names":["define","$","log","utils","debug","timeout","mediaRecorder","mediaStream","audioctx","msr","mediaType","clone","extend","init","start","timeSlice","that","mimeType","getVideoTracks","length","getAudioTracks","stream","navigator","mozGetUserMedia","MediaStream","addTrack","is_chrome","recorderHints","MediaRecorder","e","canRecordMimeType","ignoreMutedMedia","ondataavailable","data","size","blob","getNativeBlob","Blob","type","onerror","error","name","state","stop","audioInput","createMediaStreamSource","connect","audioanalyser","core","pause","resume","clearRecordedData","isMediaStreamActive","active","ended","looper","setTimeout"],"mappings":"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","sourcesContent":["/* jshint ignore:start */\ndefine(['jquery',\n        'core/log', 'filter_poodll/utils_amd'],\n    function ($, log, utils) {\n\n        \"use strict\"; // jshint ;_;\n\n        log.debug('PoodLL Plain Recorder: initialising');\n\n        return {\n            timeout: 0,\n            mediaRecorder: null,\n            mediaStream: null,\n            audioctx: null, //unused\n            msr: null,\n            mediaType: null,\n\n\n            //for making multiple instances\n            clone: function () {\n                return $.extend(true, {}, this);\n            },\n\n            // init the recorder\n            init: function (msr, mediaStream, audioctx, mediaType) {\n                this.msr = msr;\n                this.mediaStream = mediaStream;\n                this.audioctx = audioctx; //unused\n                this.mediaType = mediaType;\n            },\n\n            /**\n             * This method records MediaStream.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.record();\n             */\n            start: function (timeSlice, __disableLogs) {\n                var that = this;\n                if (!this.mimeType && this.mediaType == 'video') {\n                    this.mimeType = 'video/webm';\n                }\n\n                if (this.mediaType == 'audio') {\n                    if (this.mediaStream.getVideoTracks().length && this.mediaStream.getAudioTracks().length) {\n                        var stream;\n                        if (!!navigator.mozGetUserMedia) {\n                            stream = new MediaStream();\n                            stream.addTrack(this.mediaStream.getAudioTracks()[0]);\n                        } else {\n                            // webkitMediaStream\n                            stream = new MediaStream(this.mediaStream.getAudioTracks());\n                        }\n                        this.mediaStream = stream;\n                    }\n                }\n\n                if (this.mediaType == 'audio') {\n                    this.mimeType = utils.is_chrome() ? 'audio/webm' : 'audio/ogg';\n                }\n\n                var recorderHints = {\n                    mimeType: this.mimeType\n                };\n\n\n                // http://dxr.mozilla.org/mozilla-central/source/content/media/MediaRecorder.cpp\n                // https://wiki.mozilla.org/Gecko:MediaRecorder\n                // https://dvcs.w3.org/hg/dap/raw-file/default/media-stream-capture/MediaRecorder.html\n\n                // starting a recording session; which will initiate \"Reading Thread\"\n                // \"Reading Thread\" are used to prevent main-thread blocking scenarios\n                try {\n                    this.mediaRecorder = new MediaRecorder(this.mediaStream, recorderHints);\n                } catch (e) {\n                    // if someone passed NON_supported mimeType\n                    // or if Firefox on Android\n                    this.mediaRecorder = new MediaRecorder(this.mediaStream);\n                }\n\n                if ('canRecordMimeType' in this.mediaRecorder && this.mediaRecorder.canRecordMimeType(this.mimeType) === false) {\n                    log.debug('MediaRecorder API seems unable to record mimeType:' + this.mimeType);\n                }\n\n                // i.e. stop recording when <video> is paused by the user; and auto restart recording\n                // when video is resumed. E.g. yourStream.getVideoTracks()[0].muted = true; // it will auto-stop recording.\n                this.mediaRecorder.ignoreMutedMedia = this.ignoreMutedMedia || false;\n\n\n                // Dispatching OnDataAvailable Handler\n                this.mediaRecorder.ondataavailable = function (e) {\n                    //  log.debug('data available:' + e.data.size );\n                    if (!e.data || !e.data.size) {\n                        return;\n                    }\n\n                    var blob = that.getNativeBlob ? e.data : new Blob([e.data], {\n                        type: that.mimeType || 'video/webm'\n                    });\n\n                    that.msr.ondataavailable(blob);\n\n                };\n\n                this.mediaRecorder.onerror = function (error) {\n                    if (error.name === 'InvalidState') {\n                        log.debug('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.');\n                    } else if (error.name === 'OutOfMemory') {\n                        log.debug('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'IllegalStreamModification') {\n                        log.debug('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'OtherRecordingError') {\n                        log.debug('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'GenericError') {\n                        log.debug('The UA cannot provide the codec or recording option that has been requested.', error);\n                    } else {\n                        log.debug('MediaRecorder Error', error);\n                    }\n\n                    // When the stream is \"ended\" set recording to 'inactive'\n                    // and stop gathering data. Callers should not rely on\n                    // exactness of the timeSlice value, especially\n                    // if the timeSlice value is small. Callers should\n                    // consider timeSlice as a minimum value\n\n                    if (!!that.mediaRecorder && that.mediaRecorder.state !== 'inactive' && that.mediaRecorder.state !== 'stopped') {\n                        that.mediaRecorder.stop();\n                    }\n                };\n\n                //We need a source node to connect the analyser to. The analyser is for visualisations\n                var audioInput = this.audioctx.createMediaStreamSource(this.mediaStream);\n                audioInput.connect(this.msr.audioanalyser.core);\n\n                // void start(optional long mTimeSlice)\n                // The interval of passing encoded data from EncodedBufferCache to onDataAvailable\n                // handler. \"mTimeSlice < 0\" means Session object does not push encoded data to\n                // onDataAvailable, instead, it passive wait the client side pull encoded data\n                // by calling requestData API.\n                try {\n                    that.mediaRecorder.start(timeSlice);\n                } catch (e) {\n                    that.mediaRecorder = null;\n                }\n\n//end of start\n            },\n\n            /**\n             * This method stops recording MediaStream.\n             * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n             */\n            stop: function (callback) {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.mediaRecorder.state === 'recording') {\n                    this.mediaRecorder.stop();\n                }\n            },\n\n            /**\n             * This method pauses the recording process.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.pause();\n             */\n            pause: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.mediaRecorder.state === 'recording') {\n                    this.mediaRecorder.pause();\n                }\n            },\n\n            /**\n             * This method resumes the recording process.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.resume();\n             */\n            resume: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n                if (this.mediaRecorder.state === 'paused') {\n                    this.mediaRecorder.resume();\n                }\n            },\n\n            /**\n             * This method resets currently recorded data.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.clearRecordedData();\n             */\n            clearRecordedData: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                this.pause();\n\n                this.stop();\n            },\n\n            // Reference to \"MediaRecorder\" object\n            //  var mediaRecorder;\n\n            isMediaStreamActive: function () {\n                if ('active' in this.mediaStream) {\n                    if (!this.mediaStream.active) {\n                        return false;\n                    }\n                } else if ('ended' in this.mediaStream) { // old hack\n                    if (this.mediaStream.ended) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n\n            // this method checks if media stream is stopped\n            // or any track is ended.\n            looper: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.isMediaStreamActive() === false) {\n                    this.stop();\n                    return;\n                }\n\n                setTimeout(this.looper, 1000); // check every second\n            }\n        };// end of returned object\n    });// total end"],"file":"msr_plain.min.js"}